<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<head>
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=https://raw.githubusercontent.com/ssfwshutterbug/ssfwshutterbug.github.io/main/warn.html">
<![endif]-->
<meta charset="utf-8">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta name="author" content="shutterbug">
<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta http-equiv="mobile-agent" content="format=html5; url=https://raw.githubusercontent.com/ssfwshutterbug/ssfwshutterbug.github.io/main">
<meta http-equiv="X-DNS-Prefetch-Control" content="on">

<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">


<link rel="shortcut icon" href="/images/favicon.png">


<title>haskell - shutterbug sweet diary</title>

<meta name="keywords" content="">

<meta name="description " content="">

<!-- Jetpack Open Graph Tags -->
<meta property="og:type" content="article" />
<meta property="og:title" content="haskell - shutterbug sweet diary" />
<meta property="og:description" content="" />
<meta property="og:url" content="https://raw.githubusercontent.com/ssfwshutterbug/ssfwshutterbug.github.io/main" />
<meta property="og:site_name" content="shutterbug sweet diary" />

<link rel="dns-prefetch" href="https://raw.githubusercontent.com/ssfwshutterbug/ssfwshutterbug.github.io/main">
<link rel="prefetch" href="https://raw.githubusercontent.com/ssfwshutterbug/ssfwshutterbug.github.io/main">
<link rel="prerender" href="https://raw.githubusercontent.com/ssfwshutterbug/ssfwshutterbug.github.io/main">
<link rel="stylesheet" href="/css/JSimple.min.css">
    <script type="text/javascript">
        (function() {
            let jsi_config = {
                rootUrl: 'https://raw.githubusercontent.com/ssfwshutterbug/ssfwshutterbug.github.io/main/',
                isPost: 'true',
                buildingTime: '04/23/2022',
                snsQRCode: '',
                donateImg: '',
                readMode: 'day',
                localSearch: { dbPath: '' }
            };
            
            window.jsi_config = jsi_config;
        })()
    </script>
    
<script src="/js/SimpleCore.min.js"></script>

<meta name="generator" content="Hexo 5.4.2"></head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="S">S</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span>Home</span></a>
        <a href="/archives" title="Archives"><i class="fa fa-archives"></i><span>Archives</span></a>
        <a href="/tags" title="Tags"><i class="fa fa-tags"></i><span>Tags</span></a>
        <!-- custom single page of menus -->
        
        
        <a href="/help" title="帮助">
            <i class="fa fa-question-circle"></i>
            <span>帮助</span>
        </a>
        
    </nav>
</div>

<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    
</div>
<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <img class="cover-img" src="https://shuoit.net/images/cover-day.jpg" alt="cover-img" loading="lazy" />
    <div class="cover-info">
        
        <h1 class="cover-siteName">blog</h1>
        <h3 class="cover-siteTitle">the world you see</h3>
        <p class="cover-siteDesc">not depend on what you received but your response</p>
        <div class="cover-sns">
            
    &nbsp;&nbsp;<div class="btn btn-github">
        <a href="https://github.com/ssfwshutterbug" target="_blank" title="github" ref="friend">
            <i class="fa fa-github"></i>
        </a>
    </div>


        </div>
    </div>
</div>

            <div class="page-title">
    <ul>
        <li><a href="/">Recent Posts</a></li>
        
            
                <li class="active">
                    <a href="/categories/learn" data-name="learn">learn</a>
                </li>
            
                <li class="">
                    <a href="/categories/think" data-name="think">think</a>
                </li>
            
        
        <li class="page-search">
    <form id="search" class="search-form">
        <input type="text"
               readonly="readonly"
               id="local-search-input-tip"
               placeholder="click to search..." />
        <button type="button" disabled="disabled" class="search-form-submit"><i class="fa fa-search"></i></button>
    </form>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="https://raw.githubusercontent.com/ssfwshutterbug/ssfwshutterbug.github.io/main"
                   target="_blank">
                    <img width="48" src="/images/favicon.png" alt="avatar"/>
                </a>
                <p><span class="label">Author</span>
                    <a href="https://raw.githubusercontent.com/ssfwshutterbug/ssfwshutterbug.github.io/main"
                       target="_blank">shutterbug</a>
                    <span title="Last edited at&nbsp;2022-04-23">2022-04-23</span>
                </p>
                <p>sweet diary</p>
            </div>
            <h2 class="post-title">haskell</h2>
            <div class="post-meta">
                emm... 28972 words in the article |
                you are the&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>th friend who reading now
            </div>
        </div>
        <div class="post-content markdown-body">
            <h1 id="HASKELL"><a href="#HASKELL" class="headerlink" title="HASKELL"></a>HASKELL</h1><h2 id="what-is-haskell"><a href="#what-is-haskell" class="headerlink" title="what is haskell?"></a>what is haskell?</h2><p><strong>Haskell is a <em>purely functional programming language</em>. don’t tell the computer what to do as such but rather you tell it what stuff <em>is</em></strong></p>
<h2 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h2><ul>
<li>unchangeable variable </li>
<li>no side-effects</li>
<li>pure function</li>
<li>function must return value</li>
<li>type static</li>
<li>compile language</li>
<li>lazy calculate</li>
<li>elegant and concise</li>
</ul>
<h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><p>haskell的环境搭建包含了三个部分：</p>
<ol>
<li><p>编译器</p>
<ul>
<li>编译器使用ghc或者hugs（在使用包管理器或安装脚本时会自动安装）</li>
</ul>
</li>
<li><p>模块</p>
<p>模块安装有多种方法：</p>
<ul>
<li><p>如果是使用debian，ubuntu等操作系统，<a target="_blank" rel="noopener" href="https://www.haskell.org/platform/">包管理器提供的有完整安装包</a>，这种安装方式会自动安装后面代码提示所需要的后台服务</p>
</li>
<li><p>如果所使用的系统不在列表中，可使用官方提供的<a target="_blank" rel="noopener" href="https://www.haskell.org/ghcup/">一键安装脚本</a>，安装所有组件，包含了ghc以及包管理cabal/stack（安装完有2Gib多的空间占用）</p>
</li>
<li><p>如果觉得上面安装的文件太大，可使用系统提供的包管理器安装选择性的安装，例如archlinux可以直接使用<code>pacman</code>安装。我使用的就是这种方式，比较轻量，需要什么就安装什么。</p>
</li>
</ul>
</li>
<li><p>编辑器的代码提示</p>
<p>包含两个部分：</p>
<ul>
<li><p>后台服务：模块安装后在vscode中编辑是没有代码提示的，因为还缺少一个<code>haskell-language-server</code>，这个软件会在后台提供自动补全等功能</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S haskell-language-server</span><br></pre></td></tr></table></figure></li>
<li><p>IDE插件：vscode中安装对应的扩展插件：</p>
</li>
</ul>
<p><img src=".images/image-20210526004245891.png" alt="image-20210526004245891"></p>
</li>
</ol>
<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p><strong>虽然haskell是编译型语言，但编译器提供了直接运行的方式。虽然速度比编译后的慢</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runhaskell file.hs</span><br></pre></td></tr></table></figure>



<p><strong>编译后运行</strong></p>
<p>haskell的编译器有很多，但是这里使用ghc，archlinux下安装很简单:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S ghc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: </p>
<p>由于xmonad是使用haskell语言写的，所以安装xmonad时，已经安装了ghc，所以不需要再次下载了</p>
</blockquote>
<p><strong>交互命令行</strong></p>
<p>输入<code>ghci</code>进入交互式界面，输入<code>:quit</code>进行退出</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~  ghci</span><br><span class="line"><span class="type">GHCi</span>, version <span class="number">8.10</span>.<span class="number">4</span>: https://www.haskell.org/ghc/  :? for help</span><br><span class="line"><span class="type">Prelude</span>&gt; :quit</span><br><span class="line"><span class="type">Leaving</span> <span class="type">GHCi</span>.</span><br><span class="line"><span class="type">Prelude</span>&gt; :set prompt <span class="string">&quot;ghci &gt; &quot;</span></span><br><span class="line"><span class="title">ghci</span> &gt;</span><br></pre></td></tr></table></figure>

<p>haskell的脚本后缀为<code>.hs</code>，ghci中加载脚本文件为：<code>:l file.hs</code>. <code>:r</code>重新加载文件</p>
<h2 id="arithmetic"><a href="#arithmetic" class="headerlink" title="arithmetic"></a>arithmetic</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+	<span class="comment">--add</span></span><br><span class="line">-	<span class="comment">--subtract</span></span><br><span class="line">*	<span class="comment">--multiply</span></span><br><span class="line">/	<span class="comment">--divide</span></span><br><span class="line"><span class="title">mod</span>	<span class="comment">--remainder</span></span><br><span class="line"><span class="title">rem</span>	<span class="comment">--remainder</span></span><br></pre></td></tr></table></figure>





<h2 id="boolean-algebra"><a href="#boolean-algebra" class="headerlink" title="boolean algebra"></a>boolean algebra</h2><p>与：<code>&amp;&amp;</code></p>
<p>或：<code>||</code></p>
<p>非：<code>not</code></p>
<p>等：<code>==</code></p>
<p>不等：<code>/=</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span> &gt;&gt; <span class="type">False</span> &amp;&amp; <span class="type">True</span></span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="title">ghci</span> &gt;&gt; <span class="type">False</span> || <span class="type">True</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="title">ghci</span> &gt;&gt; not <span class="type">False</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="title">ghci</span> &gt;&gt; <span class="number">1</span> == <span class="number">0</span></span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="title">ghci</span> &gt;&gt; <span class="string">&quot;a&quot;</span> == <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="title">ghci</span> &gt;&gt; <span class="string">&quot;a&quot;</span> == <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure>





<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ol>
<li>list use <code>[]</code></li>
<li>value in list must be the <code>same type</code></li>
<li><code>String</code> is a syntactic sugar of list</li>
<li>use <code>++</code> put lists together</li>
<li><code>++</code> method will work though the first list. however <code>:</code> cons will not</li>
<li>list can be compared if the stuff they contain can be compared</li>
<li>use <code>!!</code> to get element out of a list by index. the begin index is 0</li>
<li>enumerated value can use <code>..</code> to expand needed value</li>
<li>don’t use <code>..</code> operation with float value</li>
<li><code>[1..]</code> explains all the values of nature</li>
<li><code>_</code> will ignore one value (means drop)</li>
</ol>
<p><strong>some built in function:</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; list = [<span class="number">1</span>..<span class="number">10</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; head list</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="type">Prelude</span>&gt; tail list</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; init list</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; last list</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="type">Prelude</span>&gt; list !! <span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="type">Prelude</span>&gt; length list</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="type">Prelude</span>&gt; null list</span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="type">Prelude</span>&gt; reverse list</span><br><span class="line">[<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; take <span class="number">4</span> list</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; drop <span class="number">4</span> list</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; maximum list</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="type">Prelude</span>&gt; minimum list</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="type">Prelude</span>&gt; sum list</span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="type">Prelude</span>&gt; product list</span><br><span class="line"><span class="number">3628800</span></span><br><span class="line"><span class="type">Prelude</span>&gt; elem <span class="number">5</span> list</span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="number">5</span> `elem` list</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<pre><code>some function be write in the middle of two value, such as `5 elem [1..10]`
</code></pre>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- expand value</span></span><br><span class="line"><span class="type">Prelude</span>&gt; [<span class="number">1</span>..<span class="number">10</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; [&#x27;a&#x27;..&#x27;z&#x27;]</span><br><span class="line"><span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line"><span class="type">Prelude</span>&gt; [&#x27;<span class="type">A&#x27;</span>..&#x27;<span class="type">Z&#x27;</span>]</span><br><span class="line"><span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- define steps</span></span><br><span class="line"><span class="type">Prelude</span>&gt; [<span class="number">1</span>,<span class="number">3</span>..<span class="number">20</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; [&#x27;<span class="type">A&#x27;</span>,&#x27;<span class="type">D&#x27;</span>..&#x27;<span class="type">Z&#x27;</span>]</span><br><span class="line"><span class="string">&quot;ADGJMPSVY&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<pre><code>reverse order list must define step
</code></pre>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; [<span class="number">10</span>..<span class="number">1</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="type">Prelude</span>&gt; [<span class="number">10</span>,<span class="number">9</span>..<span class="number">1</span>]</span><br><span class="line">[<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<pre><code>`take` function is very important, it works well with haskell&#39;s lazy feather
                                
`take 5 [1,5..]`
</code></pre>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; take <span class="number">20</span> $ cycle [<span class="number">1</span>..<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; take <span class="number">4</span> $ repeat [<span class="number">1</span>..<span class="number">5</span>]</span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line"><span class="type">Prelude</span>&gt; replicate <span class="number">20</span> <span class="number">1</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<p><strong>list comprehension</strong></p>
<p>list comprehension allows us do more operations with each element or filter them and return a new list.</p>
<blockquote>
<p>Note:</p>
<pre><code>`[ return expression | variable &lt;- list, filter1, filter2]`
                                
`&lt;-` means bind each element to variable
</code></pre>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; [ x^<span class="number">2</span> | x &lt;- [<span class="number">1</span>..<span class="number">10</span>]]</span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">36</span>,<span class="number">49</span>,<span class="number">64</span>,<span class="number">81</span>,<span class="number">100</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; [ x^<span class="number">2</span> | x &lt;- [<span class="number">1</span>..<span class="number">10</span>], x `mod` <span class="number">3</span> /= <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">49</span>,<span class="number">64</span>,<span class="number">100</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; [ x^<span class="number">2</span> | x &lt;- [<span class="number">1</span>..<span class="number">10</span>], x `mod` <span class="number">3</span> /= <span class="number">0</span>, x `mod` <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">16</span>,<span class="number">64</span>,<span class="number">100</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; [ x+y | x &lt;- [<span class="number">1</span>..<span class="number">3</span>], y &lt;- [(-<span class="number">1</span>),(-<span class="number">2</span>)..(-<span class="number">3</span>)]]</span><br><span class="line">[<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<pre><code>we can use function to deliver list with parameter
</code></pre>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; plus2 xs = [ x*<span class="number">2</span> | x &lt;- xs]</span><br><span class="line"><span class="type">Prelude</span>&gt; plus2 [<span class="number">1</span>..<span class="number">5</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<pre><code>we can not only operator list itself, but also use list as a condition
</code></pre>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; color xs = [ <span class="keyword">if</span> x==<span class="number">0</span> <span class="keyword">then</span> <span class="string">&quot;red&quot;</span> <span class="keyword">else</span> <span class="keyword">if</span> x==<span class="number">1</span> <span class="keyword">then</span> <span class="string">&quot;yellow&quot;</span> <span class="keyword">else</span> <span class="string">&quot;blue&quot;</span> | x &lt;- xs, x==<span class="number">0</span> || x==<span class="number">1</span> || x==<span class="number">2</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; color [<span class="number">1</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">10</span>]</span><br><span class="line">[<span class="string">&quot;yellow&quot;</span>,<span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<pre><code>we can use `_` to ignore some value
</code></pre>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; length&#x27; xs = sum [ <span class="number">1</span> | _ &lt;- xs]</span><br><span class="line"><span class="type">Prelude</span>&gt; length&#x27; [<span class="number">1</span>..<span class="number">10</span>]</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<pre><code>deal with list of lists
</code></pre>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; lists = [[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="type">Prelude</span>&gt; [[x+<span class="number">1</span> | x&lt;-xs] | xs &lt;- lists]</span><br><span class="line">[[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]]</span><br></pre></td></tr></table></figure>



<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><ol>
<li>tuple use <code>()</code></li>
<li>can contain different type values</li>
<li>tuple’s type depend on the length of tuple (means different length of tuple stands of different type) and the type of tuple’s value</li>
</ol>
<blockquote>
<p>Note:</p>
<ol>
<li><p>i still not find a good way to index the tuple, one way to index tuple is use <code>_</code> to filter no needed data. one little complex way is using <code>pattern match</code></p>
</li>
<li><p>but if the tuple only has two value, we can use two function get the value</p>
</li>
</ol>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">yohe</span> = (<span class="number">20</span>,<span class="number">170</span>,<span class="string">&quot;12312823@gmail.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- define function with pattern match</span></span><br><span class="line"><span class="title">getAge</span> xs =</span><br><span class="line">    <span class="keyword">let</span> (age,_,_) = xs</span><br><span class="line">    <span class="keyword">in</span>  print age</span><br><span class="line"><span class="comment">-- haskell will return last value be default, so `print` is optional</span></span><br><span class="line"><span class="title">getScho0l</span> xs = <span class="keyword">let</span> (_,school,_) = xs <span class="keyword">in</span> school</span><br><span class="line"><span class="comment">-- a more convient way is </span></span><br><span class="line"><span class="title">getEmail</span> (_,_,email) = email</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- we can write above in a file, then we can call it by function</span></span><br><span class="line"><span class="title">getAge</span> yohe</span><br><span class="line"><span class="title">getSchool</span> yohe</span><br><span class="line"><span class="title">getEmail</span> yohe</span><br></pre></td></tr></table></figure>



<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; yohe = (<span class="number">20</span>, <span class="string">&quot;2398422@gmail.com&quot;</span>)</span><br><span class="line"><span class="type">Prelude</span>&gt; fst yohe</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="type">Prelude</span>&gt; snd yohe</span><br><span class="line"><span class="string">&quot;2398422@gmail.com&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<pre><code>`zip` to combine two list into one tuple
                                
`unzip` can abstract tuple into two list
</code></pre>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; zip [<span class="number">1</span>..<span class="number">10</span>] [&#x27;a&#x27;..&#x27;z&#x27;]</span><br><span class="line">[(<span class="number">1</span>,&#x27;a&#x27;),(<span class="number">2</span>,&#x27;b&#x27;),(<span class="number">3</span>,&#x27;c&#x27;),(<span class="number">4</span>,&#x27;d&#x27;),(<span class="number">5</span>,&#x27;e&#x27;),(<span class="number">6</span>,&#x27;f&#x27;),(<span class="number">7</span>,&#x27;g&#x27;),(<span class="number">8</span>,&#x27;h&#x27;),(<span class="number">9</span>,&#x27;i&#x27;),(<span class="number">10</span>,&#x27;j&#x27;)]</span><br><span class="line"></span><br><span class="line"><span class="type">Prelude</span>&gt; a = zip [<span class="number">1</span>..<span class="number">10</span>] [&#x27;a&#x27;..&#x27;z&#x27;]</span><br><span class="line"><span class="type">Prelude</span>&gt; unzip a</span><br><span class="line">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>],<span class="string">&quot;abcdefghij&quot;</span>)</span><br></pre></td></tr></table></figure>





<h2 id="type-and-typeclass"><a href="#type-and-typeclass" class="headerlink" title="type and typeclass"></a>type and typeclass</h2><p>in other languages such as python, data also has type, if we write <code>1 - True</code> in file will lead a error in compile time. so how about haskell? okay, we need to say in haskell everything has a type, data, function, expression (in fact, data is included in expression)</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t <span class="number">3</span></span><br><span class="line"><span class="number">3</span> :: <span class="type">Num</span> p =&gt; p</span><br><span class="line"><span class="type">Prelude</span>&gt; :t sum</span><br><span class="line"><span class="title">sum</span> :: (<span class="type">Foldable</span> t, <span class="type">Num</span> a) =&gt; t a -&gt; a</span><br><span class="line"><span class="type">Prelude</span>&gt; :t (<span class="number">1</span>+<span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>+<span class="number">1</span>) :: <span class="type">Num</span> a =&gt; a</span><br></pre></td></tr></table></figure>

<p><strong>benefit of type</strong></p>
<ol>
<li>type told the expression or function what data type it needs</li>
<li>make it much easier to know what the function/expression means while reading type define</li>
<li>check syntax in compile time</li>
</ol>
<blockquote>
<p>Note:</p>
<ol>
<li>type is capital case in start : <code>Int, Integer, Float, Double, Bool, Char, String</code></li>
<li>use <code>::</code> to announce type definition</li>
<li>use <code>-&gt;</code> to separate parameters</li>
<li>there are two ways:<ul>
<li>with function, <code>function_name :: parameter1_type -&gt; parameter2_type -&gt; return_type</code></li>
<li>with data, <code>data :: data_type</code></li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">getEmail</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">getEmail</span> xs = <span class="keyword">let</span> (_,_,email) = xs <span class="keyword">in</span>  email</span><br><span class="line"></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="number">3</span> + <span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="number">3</span> + <span class="number">4</span> :: <span class="type">Float</span></span><br><span class="line"><span class="number">7.0</span></span><br></pre></td></tr></table></figure>



<p><strong>type variable</strong></p>
<p>some functions not only allow one unchanged data type, this kind of function called <em>polymorphic function</em>. we need to use type variable, often use single lower case character (a~z). it stands for all kinds of types</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- head allow String and Int type and others...</span></span><br><span class="line"><span class="type">Prelude</span>&gt; :t head</span><br><span class="line"><span class="title">head</span> :: [a] -&gt; a</span><br><span class="line"><span class="type">Prelude</span>&gt; head <span class="string">&quot;string&quot;</span></span><br><span class="line">&#x27;s&#x27;</span><br><span class="line"><span class="type">Prelude</span>&gt; head [<span class="number">1</span>..<span class="number">10</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="type">Prelude</span>&gt; head [<span class="number">1.0</span>..<span class="number">10.0</span>]</span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure>



<p><strong>typeclass</strong></p>
<p>A typeclass is a sort of interface that defines some behavior. If a type is a part of a typeclass, that means that it <code>supports and implements</code> the behavior the typeclass describes.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t (==)</span><br><span class="line">(==) :: <span class="type">Eq</span> a =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>

<p>Everything before the <strong>=&gt;</strong> symbol is called a <em>class constraint</em>. We can read the previous type declaration like this: the equality function takes any two values that are of the same type and returns a <strong>Bool</strong>. The type of those two values must be a member of the <strong>Eq</strong> class (this was the class constraint)</p>
<ol>
<li><p>we use <code>=&gt;</code> to announce typeclass</p>
</li>
<li><p>basic typeclass:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Eq</span>	 		used for comparing:it&#x27;s implement has method <span class="keyword">of</span> `==` `/=`</span><br><span class="line"><span class="type">Ord</span>	 		ordering: `&gt;` `&lt;` `&gt;=` `&lt;=`</span><br><span class="line"><span class="type">Show</span>		present <span class="keyword">as</span> string	`show`</span><br><span class="line"><span class="type">Read</span>		read string and return a <span class="class"><span class="keyword">type</span> of <span class="type">Read</span>	`read`</span></span><br><span class="line"><span class="type">Enum</span>		sequentially ordered types	`succ` `pred`</span><br><span class="line"><span class="type">Bounded</span>		have an upper and a lower bound</span><br><span class="line"><span class="type">Num</span>			numeric typeclass</span><br><span class="line"><span class="type">Integral</span>	only integral (whole) numbers	`fromIntegral`</span><br><span class="line"><span class="type">Floating</span>	includes only floating point numbers</span><br></pre></td></tr></table></figure></li>
<li><p>if one type belongs to one typeclass, then this type can act like other type the typeclass defined.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 5 belongs to Num typeclass, so it can be Int or Float or Double</span></span><br><span class="line"><span class="type">Prelude</span>&gt; :t <span class="number">5</span></span><br><span class="line"><span class="number">5</span> :: <span class="type">Num</span> p =&gt; p</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="number">5</span> :: <span class="type">Int</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="number">5</span> :: <span class="type">Float</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="number">5</span> :: <span class="type">Double</span></span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>Note:</p>
<ol>
<li><p>length function will return a Int value, which may lead many inconvenient</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t length</span><br><span class="line"><span class="title">length</span> :: <span class="type">Foldable</span> t =&gt; t a -&gt; <span class="type">Int</span></span><br><span class="line">                                </span><br><span class="line"><span class="type">Prelude</span>&gt; length <span class="string">&quot;hello&quot;</span> + <span class="number">4.5</span></span><br><span class="line">                                </span><br><span class="line">&lt;interactive&gt;:<span class="number">235</span>:<span class="number">18</span>: error:</span><br><span class="line">    • <span class="type">No</span> <span class="keyword">instance</span> for (<span class="type">Fractional</span> <span class="type">Int</span>) arising from the literal ‘<span class="number">4.5</span>’</span><br><span class="line">    • <span class="type">In</span> the second argument <span class="keyword">of</span> ‘(+)’, namely ‘<span class="number">4.5</span>’</span><br><span class="line">      <span class="type">In</span> the expression: length <span class="string">&quot;hello&quot;</span> + <span class="number">4.5</span></span><br><span class="line">      <span class="type">In</span> an equation for ‘it’: it = length <span class="string">&quot;hello&quot;</span> + <span class="number">4.5</span></span><br></pre></td></tr></table></figure>

<p>so why <code>fromIntegral</code> comes up</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t fromIntegral</span><br><span class="line"><span class="title">fromIntegral</span> :: (<span class="type">Integral</span> a, <span class="type">Num</span> b) =&gt; a -&gt; b</span><br><span class="line"><span class="type">Prelude</span>&gt; fromIntegral (length <span class="string">&quot;hello&quot;</span>) + <span class="number">4.5</span></span><br><span class="line"><span class="number">9.5</span></span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<p><strong>type annotations</strong></p>
<p>some functions don’t know what kind of type it will return, so we need to tell it, that’s type annotations</p>
<p>use <code>:: data_type</code> after data</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t read</span><br><span class="line"><span class="title">read</span> :: <span class="type">Read</span> a =&gt; <span class="type">String</span> -&gt; a</span><br><span class="line"><span class="type">Prelude</span>&gt; read <span class="string">&quot;3&quot;</span> :: <span class="type">Int</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>



<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><ol>
<li>function will return last calculate value by default, so  <code>return</code> keyword is optiona</li>
<li><code>return</code> keyword only told function return a value rather than pause, so the code below <code>return</code> will run continue</li>
<li>function name starts with lower case</li>
<li>args split with blank space</li>
</ol>
<p><strong>pattern matching</strong></p>
<p>much more different than any other languages, this feature in my opinion is really cool for it can do some match with parameters.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- how sum comes</span></span><br><span class="line"><span class="comment">-- for list end with [], this may lead function runs error, with pattern match, we can avoid it</span></span><br><span class="line"><span class="title">sum&#x27;</span> [] = <span class="number">0</span></span><br><span class="line"><span class="comment">-- with pattern match, we can sperate list into two parts: head value and the rest of value</span></span><br><span class="line"><span class="title">sum&#x27;</span> (x:xs) = x + sum&#x27; xs</span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- without pattern match, function like this</span></span><br><span class="line"><span class="title">yeho</span> = (<span class="number">20</span>，<span class="number">170</span>，“<span class="number">293848389</span>@gmail.com”)</span><br><span class="line"><span class="title">getEmail</span> xs = <span class="keyword">let</span> (_,_,email) = xs <span class="keyword">in</span> email</span><br><span class="line"></span><br><span class="line"><span class="comment">-- however we can directly match with parameter,cool?</span></span><br><span class="line"><span class="title">yeho</span> = (<span class="number">20</span>，<span class="number">170</span>，“<span class="number">293848389</span>@gmail.com”)</span><br><span class="line"><span class="title">getEmail</span> (_,_,email) = email</span><br><span class="line"></span><br><span class="line"><span class="comment">-- without pattern match, head like this</span></span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;empty list&quot;</span></span><br><span class="line"><span class="title">head&#x27;</span> x = x !! <span class="number">0</span></span><br><span class="line"><span class="comment">-- with parameter match, head like this, cool?</span></span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;empty list&quot;</span></span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x</span><br></pre></td></tr></table></figure>

<p>pattern matching also can act like if statement</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">color</span> <span class="number">0</span> = <span class="string">&quot;red&quot;</span></span><br><span class="line"><span class="title">color</span> <span class="number">1</span> = <span class="string">&quot;yellow&quot;</span></span><br><span class="line"><span class="title">color</span> <span class="number">2</span> = <span class="string">&quot;blue&quot;</span></span><br><span class="line"><span class="title">color</span> _ =  <span class="string">&quot;not origion triple color&quot;</span></span><br></pre></td></tr></table></figure>



<p><strong>guard</strong></p>
<p>guards are a way of testing whether some property of a value (or several of them) are true or false. much more like if statement.</p>
<ol>
<li>no <code>=</code> sign after parameter</li>
<li>use <code>|</code> to sign begin</li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">adjudge</span> :: (<span class="type">Ord</span> a, <span class="type">Num</span> a) =&gt; a -&gt; [<span class="type">Char</span>]</span><br><span class="line"><span class="title">adjudge</span> score</span><br><span class="line">    | score &gt;= <span class="number">90</span> = <span class="string">&quot;perfect&quot;</span></span><br><span class="line">    | score &gt;= <span class="number">80</span> = <span class="string">&quot;good&quot;</span></span><br><span class="line">    | score &gt;= <span class="number">60</span> = <span class="string">&quot;not bad&quot;</span></span><br><span class="line">    | score &gt;= <span class="number">0</span> = <span class="string">&quot;not pass&quot;</span></span><br><span class="line">    | otherwise = <span class="string">&quot;error score&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>otherwise</code> is optional, but it is often useful for catching everything</p>
<p>with <strong>where</strong> we can also use local variables in guard</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">total</span> :: (<span class="type">Ord</span> a, <span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; [<span class="type">Char</span>]</span><br><span class="line"><span class="title">total</span> math english history</span><br><span class="line">    | score &gt; lineup = <span class="string">&quot;perfect&quot;</span></span><br><span class="line">    | score &gt; passline = <span class="string">&quot;good&quot;</span></span><br><span class="line">    | otherwise = <span class="string">&quot;hurry up&quot;</span></span><br><span class="line">    <span class="keyword">where</span> score = math + english + history</span><br><span class="line">          lineup = <span class="number">400</span></span><br><span class="line">          passline = <span class="number">200</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<ol>
<li>the indent below where is hard to specify, for it is not 2 tab but 6 blank space (1tab + 2black space)</li>
<li>in where binding, we can define variable</li>
<li>in where binding, we can use pattern match</li>
<li>in where binging, we can use function</li>
</ol>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">total</span> :: (<span class="type">Ord</span> a, <span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; [<span class="type">Char</span>]</span><br><span class="line"><span class="title">total</span> math english history</span><br><span class="line">    | score &gt; lineup = <span class="string">&quot;perfect&quot;</span></span><br><span class="line">    | score &gt; passline = <span class="string">&quot;good&quot;</span></span><br><span class="line">    | otherwise = <span class="string">&quot;hurry up&quot;</span></span><br><span class="line">    <span class="keyword">where</span> score = math + english + history</span><br><span class="line">          (lineup,passline) = (<span class="number">400</span>,<span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.List.Split</span><br><span class="line"></span><br><span class="line"><span class="title">email</span> :: [<span class="type">Char</span>] -&gt; [<span class="type">Char</span>]</span><br><span class="line"><span class="title">email</span> addr</span><br><span class="line">    | end == <span class="string">&quot;gmail.com&quot;</span> = <span class="string">&quot;gmail&quot;</span></span><br><span class="line">    | end == <span class="string">&quot;qq.com&quot;</span> = <span class="string">&quot;qq&quot;</span></span><br><span class="line">    | end == <span class="string">&quot;163.com&quot;</span> = <span class="string">&quot;163&quot;</span></span><br><span class="line">    | otherwise = <span class="string">&quot;error email address&quot;</span></span><br><span class="line">    <span class="keyword">where</span> [_,end] = splitOn <span class="string">&quot;@&quot;</span> addr</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- run result</span></span><br><span class="line">*<span class="type">Main</span>&gt; email <span class="string">&quot;20398442@qq.com&quot;</span></span><br><span class="line"><span class="string">&quot;qq&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zip&#x27;</span> xs ys = [f x y | x &lt;- xs, y &lt;- ys]</span><br><span class="line">    <span class="keyword">where</span> f x y = (x, y)</span><br></pre></td></tr></table></figure>



<p><strong>let</strong> works similar like where, but it can write in anywhere in function not only in the end</p>
<p>syntax: <code>let binding in expression</code></p>
<p><strong>the difference between let and where is that let binding itself is expression</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">let</span> (a,b,c) = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">in</span> a+b+c) * <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p><code>if else</code> statement is an expression and we can cram it in almost anywhere, so do <code>let</code> binding. and i wanna to say let binding is so flexible and cool</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- simple calculate expression</span></span><br><span class="line"><span class="number">3</span> + (<span class="keyword">let</span> a=<span class="number">2</span> <span class="keyword">in</span> a^<span class="number">2</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- list expression</span></span><br><span class="line">[ m | x &lt;- [<span class="number">1</span>..<span class="number">10</span>], <span class="keyword">let</span> m = x * <span class="number">2</span> + <span class="number">1</span>, m &gt; <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- function expression</span></span><br><span class="line"><span class="title">let</span> add1 x = x + <span class="number">1</span> <span class="keyword">in</span> (add1 <span class="number">1</span>, add1 <span class="number">2</span>, add1 <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- pattern match</span></span><br><span class="line"><span class="title">let</span> (a,b,c) = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">in</span> a^<span class="number">2</span> + b^<span class="number">2</span> + c^<span class="number">2</span></span><br></pre></td></tr></table></figure>



<h2 id="case-expression"><a href="#case-expression" class="headerlink" title="case expression"></a>case expression</h2><p>case is expression,so what about it? that means we can use pattern matching with case value</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- syntax</span></span><br><span class="line"><span class="title">case</span> expression <span class="keyword">of</span> pattern -&gt; result</span><br><span class="line">				   pattern -&gt; result</span><br><span class="line">				   pattern -&gt; result</span><br><span class="line">				   ...</span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">head&#x27;</span> xs = <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; error <span class="string">&quot;empty list&quot;</span></span><br><span class="line">                      (x:xs) -&gt; x</span><br></pre></td></tr></table></figure>



<h2 id="recursion"><a href="#recursion" class="headerlink" title="recursion"></a>recursion</h2><p>for haskell is a language that higher than any other languages, and it ignores how to do it but tells what it is, so the implementation of loop will be instead of recursion. that is why recursion so important in haskell.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">max&#x27;</span> :: <span class="type">Ord</span> a =&gt; [a] -&gt; a </span><br><span class="line"><span class="comment">-- edge condition with pattern match</span></span><br><span class="line"><span class="title">max&#x27;</span> [] = error <span class="string">&quot;empty list&quot;</span></span><br><span class="line"><span class="title">max&#x27;</span> [x] = x</span><br><span class="line"><span class="title">max&#x27;</span> (x:xs)</span><br><span class="line"><span class="comment">-- don&#x27;t need to do loop condition, but to say head number greater than </span></span><br><span class="line"><span class="comment">-- tail numbers (rest of the list number)</span></span><br><span class="line">    | x &gt; restList = x</span><br><span class="line">    | otherwise = restList</span><br><span class="line">    <span class="keyword">where</span> restList = max&#x27; xs</span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">take&#x27;</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">take&#x27;</span> _ [] = []</span><br><span class="line"><span class="title">take&#x27;</span> n (x:xs)</span><br><span class="line">    | n &lt;= <span class="number">0</span> = []</span><br><span class="line">    | otherwise = x : take&#x27; (n-<span class="number">1</span>) xs</span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">reverse&#x27;</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">reverse&#x27;</span> [] = []</span><br><span class="line"><span class="title">reverse&#x27;</span> (x:xs) = reverse&#x27; xs ++ [x]</span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">repeat&#x27;</span> :: a -&gt; [a]</span><br><span class="line"><span class="title">repeat&#x27;</span> x = x:repeat&#x27; x</span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- notice the type define</span></span><br><span class="line"><span class="title">zip&#x27;</span> :: [a] -&gt; [b] -&gt; [(a,b)]</span><br><span class="line"><span class="title">zip&#x27;</span> [] _ = []</span><br><span class="line"><span class="title">zip&#x27;</span> _ [] = []</span><br><span class="line"><span class="title">zip&#x27;</span> (x:xs) (y:ys) = (x,y) : zip&#x27; xs ys</span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">elem&#x27;</span> :: <span class="type">Eq</span> a =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="title">elem&#x27;</span> m [] = <span class="type">False</span></span><br><span class="line"><span class="title">elem&#x27;</span> m (x:xs) </span><br><span class="line">    | m == x = <span class="type">True</span> </span><br><span class="line">    | otherwise = elem&#x27; m xs</span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">dropBlank&#x27;</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">dropBlank&#x27;</span> [] = []</span><br><span class="line"><span class="title">dropBlank&#x27;</span> (x:xs)</span><br><span class="line">    | x == &#x27; &#x27; = <span class="string">&quot;&quot;</span> ++ dropBlank&#x27; xs</span><br><span class="line">    | otherwise = x:dropBlank&#x27; xs</span><br></pre></td></tr></table></figure>



<p><strong>quick sort</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">quicksort</span> :: <span class="type">Ord</span> a =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">quicksort</span> [] = []</span><br><span class="line"><span class="title">quicksort</span> (x:xs) =</span><br><span class="line">    <span class="keyword">let</span> smallsort = quicksort [m | m &lt;- xs, m &lt;= x]</span><br><span class="line">        bigsort = quicksort [m | m &lt;- xs, m &gt; x]</span><br><span class="line">    <span class="keyword">in</span> smallsort ++ [x] ++ bigsort</span><br></pre></td></tr></table></figure>





<h2 id="modules-import"><a href="#modules-import" class="headerlink" title="modules import"></a>modules import</h2><p>syntax for importing modules</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- in haskell file</span></span><br><span class="line"><span class="comment">-- in this way, we can call the module&#x27;s function name directly</span></span><br><span class="line"><span class="keyword">import</span> module_name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- in ghci</span></span><br><span class="line">:m + module_name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- import some of function in module</span></span><br><span class="line"><span class="keyword">import</span> module_name (<span class="title">func1</span>,<span class="title">func2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- import all function in module expect someone</span></span><br><span class="line"><span class="keyword">import</span> module_name <span class="keyword">hiding</span> (<span class="title">func</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- in some case, two or more modules contains the function with the same name</span></span><br><span class="line"><span class="comment">-- in order to distinguish the function, we can use qualified keyword</span></span><br><span class="line"><span class="comment">-- if the module imported with qualified, the way to call function need to </span></span><br><span class="line"><span class="comment">-- be prefixed with module name</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> module_name</span><br><span class="line"><span class="comment">-- call function</span></span><br><span class="line"><span class="title">module_name</span>.func</span><br><span class="line"></span><br><span class="line"><span class="comment">-- in order to simplify above calling style, we can use alias to instead the </span></span><br><span class="line"><span class="comment">-- long syntax of calling function</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> module_name <span class="keyword">as</span> alias_name</span><br><span class="line"><span class="comment">-- call function</span></span><br><span class="line"><span class="title">alias_name</span>.func</span><br><span class="line"><span class="comment">-- eg:</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Map <span class="keyword">as</span> M</span><br><span class="line"><span class="type">M</span>.filter</span><br></pre></td></tr></table></figure>





<h2 id="higher-order-function"><a href="#higher-order-function" class="headerlink" title="higher order function"></a>higher order function</h2><p><strong>curried function</strong></p>
<p>another part that function program is different with other language is <code>curried function</code> (one function takes more than one parameters). it is a <code>concept </code> which helps us to think functions in another way. in order to understand the concept, we need to know the following point:</p>
<ol>
<li>putting a space between two things is simply <code>function application</code></li>
<li>every function in haskell officially only takes one parameter</li>
<li>if a function need more than one parameters, the one we write that function with too few parameters is called <code>function on the fly (or called partial application)</code> . we can pass it to another function as parameter</li>
</ol>
<p>so, we may though, okay, i know that’s it, and what does it helpful for my coding? let’s see this function and you will understand how powerful this concept</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- * is also a function which need two parameters</span></span><br><span class="line"><span class="comment">-- (*2) is a function on the fly</span></span><br><span class="line"><span class="title">plus2</span> xs = map (*<span class="number">2</span>) xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- / is a function which need two parameters</span></span><br><span class="line"><span class="comment">-- (/10) is a function on the fly</span></span><br><span class="line"><span class="title">divideByTen</span> x = (/<span class="number">10</span>) x</span><br></pre></td></tr></table></figure>

<p>if without curried function, above may need to be write as this</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum&#x27;</span> (x:xs) = x + sum&#x27; xs</span><br><span class="line"><span class="title">plus2</span> xs = map (\x -&gt; x*<span class="number">2</span>) xs</span><br></pre></td></tr></table></figure>

<p>with this concept we can though a function with many parameters is a function take one parameter then return a new function, the new function takes another parameter and then return a new function and so on…</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">multithree</span> :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">multithree</span> x y z = x * y * z</span><br><span class="line"></span><br><span class="line"><span class="comment">-- with curried function concept, we can write type as this</span></span><br><span class="line"><span class="title">multithree</span> :: <span class="type">Num</span> a =&gt; a -&gt; (a -&gt; (a -&gt; a))</span><br><span class="line"><span class="title">multithree</span> x y z = x * y * z</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<p>function on the fly don’t means a function only takes one parameter,  it can take more than one parameter. both of them can be called function on the fly.</p>
<p>eg: <code>multithree x</code> is a function on the fly, <code>multithree x y</code> is also a function on the fly</p>
</blockquote>
<p><em>variable name of function on the fly</em></p>
<p>have we notice that a function takes one (or more) parameter <strong>returns a new function</strong>, how great this means? now we can write above function like this:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">plus2</span> = map (*<span class="number">2</span>)</span><br><span class="line"><span class="title">divideByTen</span> = (/<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<p><strong>it is not means we ignore function parameters, left side is just a new function name (yeah a variable)</strong></p>
<p>in this way, function can be greatly simplified.</p>
</blockquote>
<p><strong>function as a parameter</strong></p>
<p>we know that function can take function as parameter and also return functions</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">applyTwice</span> :: (a -&gt; a) -&gt; a -&gt; a  </span><br><span class="line"><span class="title">applyTwice</span> f x = f (f x)  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- then we can pass function to it</span></span><br><span class="line"><span class="title">applyTwice</span> (<span class="number">3</span>:) <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>notice that the function we pass to it is a function on the fly. in this way we abstract function as a variable or called parameter, so we can pass different function to it.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zipWith&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</span><br><span class="line"><span class="title">zipWith&#x27;</span> _ [] _ = []</span><br><span class="line"><span class="title">zipWith&#x27;</span> _ _ [] = []</span><br><span class="line"><span class="title">zipWith&#x27;</span> f (x:xs) (y:ys) = f x y : zipWith&#x27; f xs ys</span><br></pre></td></tr></table></figure>



<p><strong>higher order function</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- combine two list into one list with specified function</span></span><br><span class="line"><span class="title">zipWith</span> f x y</span><br><span class="line"></span><br><span class="line"><span class="title">zipWith&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</span><br><span class="line"><span class="title">zipWith&#x27;</span> _ [] _ = []</span><br><span class="line"><span class="title">zipWith&#x27;</span> _ _ [] = []</span><br><span class="line"><span class="title">zipWith&#x27;</span> f (x:xs) (y:ys) = f x y : zipWith&#x27; f xs ys</span><br><span class="line"></span><br><span class="line"><span class="comment">-- apply specified function to all elements of list</span></span><br><span class="line"><span class="title">map</span> f x</span><br><span class="line"></span><br><span class="line"><span class="title">map&#x27;</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">map&#x27;</span> _ [] = []</span><br><span class="line"><span class="title">map&#x27;</span> f (x:xs) = f x : map&#x27; f xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- filter all list elements to specified function</span></span><br><span class="line"><span class="title">filter</span> f x</span><br><span class="line"></span><br><span class="line"><span class="title">filter&#x27;</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">filter&#x27;</span> _ [] = []</span><br><span class="line"><span class="title">filter&#x27;</span> f (x:xs)</span><br><span class="line">    | f x = x : filter&#x27; f xs</span><br><span class="line">    | otherwise = filter&#x27; f xs</span><br></pre></td></tr></table></figure>



<p><strong>lambda</strong></p>
<p>we know higher order function need a parameter of function, normally, we pass a lambda to it.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- syntax</span></span><br><span class="line">(\parameter1 parameter2 -&gt; function body)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note</p>
<p>partial application can do the same thing as lambda when the function is simple. so consider use partial application first if it can</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- we can do simple pattern match in lambda</span></span><br><span class="line"><span class="title">map</span> (\(a,b) -&gt; a + b) [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">6</span>)]</span><br></pre></td></tr></table></figure>



<p><strong>fold</strong></p>
<p>some functions encapsulate common pattern <code>(x:xs)</code> with edge condition (such as map) and return one value are called fold.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- fold function need a start value and a accumulator</span></span><br><span class="line"><span class="comment">-- eg : start value &quot;False&quot; accumulator &quot;acc&quot;</span></span><br><span class="line"><span class="title">elem&#x27;</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="title">elem&#x27;</span> m xs = foldl (\acc x -&gt; <span class="keyword">if</span> m == x <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> acc) <span class="type">False</span> xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- this function can be simplified to </span></span><br><span class="line"><span class="title">elem&#x27;</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="title">elem&#x27;</span> m = foldl (\acc x -&gt;  m == x || acc) <span class="type">False</span></span><br></pre></td></tr></table></figure>

<p><code>foldl</code> work though list from left, <code>foldr</code> work though list from right. </p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum&#x27;</span> xs = foldl (\acc x -&gt; acc + x) <span class="number">0</span> xs</span><br><span class="line"></span><br><span class="line"><span class="title">sum&#x27;</span> xs = foldr (\x acc -&gt; x + acc) <span class="number">0</span> xs</span><br></pre></td></tr></table></figure>

<p><code>acc</code>‘s position is very important.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- foldr will take start value as the second parameter</span></span><br><span class="line"><span class="title">map&#x27;</span> f xs = foldr (\x acc -&gt; f x : acc) [] xs</span><br><span class="line"><span class="comment">-- foldl will take start value as the first parameter</span></span><br><span class="line"><span class="title">map&#x27;</span> f xs = foldl (\acc x -&gt; acc ++ [f x]) [] xs</span><br></pre></td></tr></table></figure>

<p><code>foldl1</code> <code>foldr1</code> almost the same as <code>foldl</code> <code>foldr</code>. only <code>foldl1</code> and <code>foldr1</code> take list’s first/last value as the starting value, so we don’t need to write. with this, we need to confirm the list is not empty, or it may crash</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum&#x27;</span> xs = foldl1 (\acc x -&gt; acc + x) xs</span><br><span class="line"><span class="title">sum&#x27;</span> xs = foldr1 (\x acc -&gt; x + acc) xs</span><br></pre></td></tr></table></figure>



<p><strong>function application with $</strong></p>
<p>function application with <code>$</code> is right-associative, which act as <code>()</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum</span> ([<span class="number">1</span>..<span class="number">10</span>] ++ [<span class="number">2</span>..<span class="number">20</span>])</span><br><span class="line"><span class="comment">-- with $</span></span><br><span class="line"><span class="title">sum</span> $ [<span class="number">1</span>..<span class="number">10</span>] ++ [<span class="number">2</span>..<span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<p><strong>function composition with .</strong></p>
<p>function composition with <code>.</code> compose two functions into one, and it is also right-associative</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> . g = \x f (g x)</span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> (\x -&gt; (+<span class="number">1</span>) (x/<span class="number">10</span>)) [<span class="number">1</span>..<span class="number">10</span>]</span><br><span class="line"><span class="title">map</span> ((+<span class="number">1</span>) . (/<span class="number">10</span>)) [<span class="number">1</span>..<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<ol>
<li><p>the principle that we can write compose function is the right function return value’s type is the same as left function parameter</p>
</li>
<li><p>if the right function takes more than one value, we need pass other parameters to the function</p>
</li>
</ol>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">show</span> . replicate <span class="number">3</span> . max <span class="number">6</span> $ <span class="number">8</span></span><br></pre></td></tr></table></figure>









<h2 id="type-and-typeclass-1"><a href="#type-and-typeclass-1" class="headerlink" title="type and typeclass"></a>type and typeclass</h2><p>so, what the data type can help me?</p>
<ol>
<li>with value constructor, help me to store data with associate relationship and with default method to get them out</li>
<li>without value constructor, help me to store data with the value name</li>
</ol>
<h3 id="data-type"><a href="#data-type" class="headerlink" title="data type"></a>data type</h3><p>haskell has already provided us basic data type like <code>Int, Float, Bool, String</code>. we can also define ourself data type</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- syntax: </span></span><br><span class="line"><span class="comment">-- type_name should be capital case</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> type_name = value_constructor</span></span><br></pre></td></tr></table></figure>



<h3 id="value-parameter"><a href="#value-parameter" class="headerlink" title="value parameter"></a>value parameter</h3><p>after value constructor, we can add some data types define the value it will contain</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Circle , Rectangle are value constructor</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<ol>
<li><p>we can thought value constructor as function, it returns a data type</p>
</li>
<li><p>however we can not directly call value constructor, because it has no method to display our data.</p>
</li>
<li><p>we can apply <em><strong><code>deriving (basic typeclass)</code></strong></em> to data type, then the data type will has the properity of basic typeclass</p>
</li>
<li><p>we can use pattern match with value constructor</p>
</li>
</ol>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">surface</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Circle</span> _ _ r) = pi * r ^ <span class="number">2</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Rectangle</span> x1 y1 x2 y2) = (abs $ x1 -x2) * (abs $ y1 -y2)</span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; surface $ <span class="type">Circle</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">78.53982</span></span><br><span class="line">*<span class="type">Main</span>&gt; <span class="type">Circle</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="type">Circle</span> <span class="number">3.0</span> <span class="number">4.0</span> <span class="number">5.0</span></span><br></pre></td></tr></table></figure>

<p>for value constructor can act as function, we can use partial application with it</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; map (<span class="type">Circle</span> <span class="number">3</span> <span class="number">4</span>) [<span class="number">1</span>..<span class="number">5</span>]</span><br><span class="line">[<span class="type">Circle</span> <span class="number">3.0</span> <span class="number">4.0</span> <span class="number">1.0</span>,<span class="type">Circle</span> <span class="number">3.0</span> <span class="number">4.0</span> <span class="number">2.0</span>,<span class="type">Circle</span> <span class="number">3.0</span> <span class="number">4.0</span> <span class="number">3.0</span>,<span class="type">Circle</span> <span class="number">3.0</span> <span class="number">4.0</span> <span class="number">4.0</span>,<span class="type">Circle</span> <span class="number">3.0</span> <span class="number">4.0</span> <span class="number">5.0</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<p>often we write data type name  the same as value constructor name if there is only one value constructor</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<p>we can use the data type in other data type define</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Point</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Point</span> <span class="type">Point</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<p>in this way, we can make Shape data type more readable</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">surface</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Circle</span> _ r) = pi * r ^ <span class="number">2</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Rectangle</span> (<span class="type">Point</span> x1 y1) (<span class="type">Point</span> x2 y2)) = (abs $ x1 -x2) * (abs $ y1 -y2)</span><br></pre></td></tr></table></figure>



<h3 id="record-syntax"><a href="#record-syntax" class="headerlink" title="record syntax"></a>record syntax</h3><p>the way above data type define is not bad, but there are some inconvenient : </p>
<p>such as :</p>
<ol>
<li><p>how to get the value of a data type?  </p>
</li>
<li><p>how to easily distinguish each value?</p>
</li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sign each type a variable name, seperate with comma</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> &#123; <span class="title">age</span> :: <span class="type">Int</span>  </span></span><br><span class="line"><span class="class">                     , <span class="title">height</span> :: <span class="type">Float</span>  </span></span><br><span class="line"><span class="class">                     , <span class="title">phoneNumber</span> :: <span class="type">String</span>  </span></span><br><span class="line"><span class="class">                     &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)   </span></span><br></pre></td></tr></table></figure>

<p>By using record syntax to create this data type, Haskell <em><strong>automatically make these functions with the name of type name:</strong></em> age height phoneNumber</p>
<blockquote>
<p>Note:</p>
<p><strong>with the default method, we can get specified value we need out of the data type</strong></p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">john</span> = <span class="type">Person</span> &#123;age=<span class="number">20</span>, height=<span class="number">170</span>, phoneNumber=<span class="string">&quot;2837109292&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">*<span class="type">Main</span>&gt; age john</span><br><span class="line"><span class="number">20</span></span><br><span class="line">*<span class="type">Main</span>&gt; phoneNumber john</span><br><span class="line"><span class="string">&quot;2837109292&quot;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> = map (<span class="type">Person</span> 20 170) [&quot;4532232&quot;, &quot;9023482&quot;, &quot;0923842&quot;]</span></span><br><span class="line"><span class="class">*<span class="type">Main</span>&gt; map phoneNumber classes</span></span><br><span class="line"><span class="class">[&quot;4532232&quot;,&quot;9023482&quot;,&quot;0923842&quot;]</span></span><br><span class="line"><span class="class">*<span class="type">Main</span>&gt; phoneNumber $ classes !! 0</span></span><br><span class="line"><span class="class">&quot;4532232&quot;</span></span><br></pre></td></tr></table></figure>





<h3 id="type-parameter"><a href="#type-parameter" class="headerlink" title="type parameter"></a>type parameter</h3><p>the same as value parameter,  <em><strong>type constructors</strong></em> can take types as parameters to produce new types</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- eg: a after Maybe is a type parameter</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a  </span></span><br></pre></td></tr></table></figure>

<p>with a parameter, we call data type as <strong>data constructor</strong></p>
<p>the benefit of type parameter is that the data type depends on what we pass to it.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> a b c = <span class="type">Person</span> &#123; <span class="title">age</span> :: <span class="title">a</span>  </span></span><br><span class="line"><span class="class">                             , <span class="title">height</span> :: <span class="title">b</span>  </span></span><br><span class="line"><span class="class">                             , <span class="title">phoneNumber</span> :: <span class="title">c</span>  </span></span><br><span class="line"><span class="class">                             &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>) </span></span><br></pre></td></tr></table></figure>

<p>without value constructor store data with value name</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Day</span> = <span class="type">Monday</span> | <span class="type">Tuesday</span> | <span class="type">Wednesday</span> | <span class="type">Thursday</span> | <span class="type">Friday</span> | <span class="type">Saturday</span> | <span class="type">Sunday</span>   </span></span><br><span class="line">	<span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>, <span class="type">Enum</span>)  </span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Monday</span> <span class="comment">--with Show, call directly</span></span><br><span class="line"><span class="type">Monday</span> == <span class="type">Monday</span> <span class="comment">--with Eq, compare directly</span></span><br><span class="line"><span class="title">read</span> <span class="string">&quot;Monday&quot;</span> :: <span class="type">Day</span> <span class="comment">--with Read, convert value from String</span></span><br><span class="line"><span class="type">MinBound</span> <span class="comment">--with Bounded, get min/max value</span></span><br><span class="line">[<span class="type">Monday</span>..<span class="type">Sunday</span>] <span class="comment">--with Enum, list range with value</span></span><br></pre></td></tr></table></figure>



<h3 id="type-synonyms"><a href="#type-synonyms" class="headerlink" title="type synonyms"></a>type synonyms</h3><p>data type’s alias, with it we can make our type declaration more clearly</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- String is alias of [Char]</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">String</span> = [<span class="type">Char</span>]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- can have parameters</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">AssocList</span> k v = [(<span class="title">k</span>,<span class="title">v</span>)]  </span></span><br><span class="line"><span class="comment">-- can partically apply type parameters</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">IntMap</span> v = <span class="type">Map</span> <span class="type">Int</span> v  </span></span><br><span class="line"><span class="comment">-- or ignore</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">IntMap</span> = <span class="type">Map</span> <span class="type">Int</span>  </span></span><br></pre></td></tr></table></figure>







<h2 id="third-module"><a href="#third-module" class="headerlink" title="third module"></a>third module</h2><p><a target="_blank" rel="noopener" href="https://hackage.haskell.org/packages/">haskell官方</a>提供了丰富的模块，可以根据需要选择对应的模块进行下载。</p>
<h3 id="Shell-Script"><a href="#Shell-Script" class="headerlink" title="Shell Script"></a>Shell Script</h3><p>haskell的<code>turtle</code>模块嵌入了shell脚本，实现了很多的unix命令，方便我们使用haskell写shell脚本。同时还支持直接调用系统的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install turtle <span class="keyword">in</span> archlinux</span></span><br><span class="line">pacman -S haskell-turtle</span><br></pre></td></tr></table></figure>

<p><strong>print text to screen</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不使用turtle模块,使用内置的System.IO</span></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	putStrLn <span class="string">&quot;hello world!&quot;</span></span><br><span class="line">	print <span class="string">&quot;hello world!&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">-- 使用turtle模块的echo命令</span></span><br><span class="line"><span class="keyword">import</span> Turtule</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Text <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">import</span> Data.Maybe</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	<span class="comment">-- echo 需要Line数据类型,使用repr可获得Line</span></span><br><span class="line">	echo $ repr <span class="string">&quot;hello world!&quot;</span></span><br><span class="line">	<span class="comment">-- 或者使用Data.Text来获取Text，使用textToLine获取Maybe Line,使用fromJust 获取Line</span></span><br><span class="line">	<span class="comment">-- 需要导入Data.Maybe Data.Text</span></span><br><span class="line">	echo $ fromJust $ textToLine $ <span class="type">T</span>.pack <span class="string">&quot;hello world!&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面这种方式太麻烦，实际上是在文件开头添加<code>&#123;-# LANGUAGE OverloadedStrings #-&#125;</code>，这样String会成为Text类型</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;-# LANGUAGE OverloadedStrings #-&#125;</span><br><span class="line"></span><br><span class="line">import Turtle</span><br><span class="line"></span><br><span class="line">main = do</span><br><span class="line">    shell &quot;ls -alh /home&quot; empty</span><br></pre></td></tr></table></figure>





<p><strong>get command output</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Turtle</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    dir &lt;- pwd </span><br><span class="line">    echo $ repr dir</span><br><span class="line"></span><br><span class="line">    time &lt;- date </span><br><span class="line">    echo $ repr time</span><br></pre></td></tr></table></figure>



<p><strong>execute system command</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Turtle</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Text <span class="keyword">as</span> T</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	<span class="comment">-- 打开浏览器</span></span><br><span class="line">	<span class="comment">-- shell需要接受一个Text数据类型</span></span><br><span class="line">	<span class="keyword">let</span> cmd = <span class="type">T</span>.pack <span class="string">&quot;firefox&quot;</span></span><br><span class="line">	shell cmd empty</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- ps查看进程</span></span><br><span class="line">	shell (<span class="type">T</span>.pack <span class="string">&quot;ps -ef |grep firefox&quot;</span>)  empty</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- 调用ls命令，内置的ls命令无法添加参数，使用这种方式可以加参数</span></span><br><span class="line">	shell (<span class="type">T</span>.pack <span class="string">&quot;ls -alh $HOME&quot;</span> |grep rc)  empty</span><br></pre></td></tr></table></figure>





<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><h4 id="problem-of-dynamic-link"><a href="#problem-of-dynamic-link" class="headerlink" title="problem of dynamic link"></a>problem of dynamic link</h4><p><strong>Err：</strong>vscode中运行正常，但是编译报错无法找到Prelude</p>
<p><img src=".images/image-20210527200039979.png" alt="image-20210527200039979"></p>
<p><strong>Cause:</strong> <a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/Haskell#Configuration">ghc 8.0.2-1</a>版本只支持动态链接库，而编译默认使用的是静态链接。</p>
<p><strong>Fix:</strong></p>
<ol>
<li><p>编译的时候添加动态链接参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ghc --dynamic file_name.hs</span><br></pre></td></tr></table></figure>

<p>为了方便，可以用alias重写ghc</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add to ~/.zshrc</span></span><br><span class="line">alias ghc=&quot;ghc -dynamic&quot;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>配置cabal/stack使用动态库，配置方法参考<a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/Haskell#Configuration">arch wiki</a></li>
</ol>
</li>
</ol>
<h4 id="cannot-find-module-which-has-been-installed"><a href="#cannot-find-module-which-has-been-installed" class="headerlink" title="cannot find module which has been installed"></a>cannot find module which has been installed</h4><p><strong>Err:</strong> 使用cabal安装模块后，依然无法导入，报错无法找到模块</p>
<p><strong>Cause:</strong> 在安装cabal之前系统已经存在ghc，导致安装cabal时编译的是系统的ghc</p>
<p><strong>Fix：</strong>解决方法很简单，使用系统的ghc就可以了（注释掉安装时配置的环境变量）</p>

            
                
            
        </div>
        <div class="post-tool">
            <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> Donate
            </a>
        </div>
        
        <div class="post-tags">Tags：
            
            <a href="/tags/haskell/">haskell</a>
            
        </div>
        
    </article>
    
        <p style="text-align: center">This article just represents my own viewpoint. If there is something wrong, please correct me.</p>
    
    
    

</div>


        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner" style="text-align: center">
        <p>
            <a href="/about"  title="About">About</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- 自定义链接 -->
            <a href="/help" title="Help" >Help</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/links" title="Links">Links</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/sitemap.xml" title="SiteMap">SiteMap</a>
        </p>
        <p>
            Has been established&nbsp<a href="/timeline" id="siteBuildingTime"></a>&nbspDays，<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="licence">Based on Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a><br/>
            ©2017-<span id="cpYear"></span> Based on&nbsp<a href="http://hexo.io" target="_blank" rel="nofollow">Hexo</a>
            ，Theme by&nbsp&nbsp<a href="https://github.com/tangkunyin/hexo-theme-jsimple" target="_blank" rel="bookmark">JSimple</a>
            ，Author&nbsp<a href="https://raw.githubusercontent.com/ssfwshutterbug/ssfwshutterbug.github.io/main" target="_blank" rel="friend">shutterbug</a>
            ，Hosted by <a href="https://pages.github.com/" target="_blank" rel="nofollow">GitHub Pages</a>
            
        </p>
    </div>
</footer>
</div>
<!-- search pop -->
<div class="popup search-popup local-search-popup">
    <div class="local-search-header clearfix">
        <span class="search-icon">
            <i class="fa fa-search"></i>
        </span>
        <span class="popup-btn-close">
            <i class="fa fa-times-circle"></i>
        </span>
        <div class="local-search-input-wrapper">
            <input id="local-search-input"
                   spellcheck="false"
                   type="text"
                   autocomplete="off"
                   placeholder="Input query keywords here..."/>
        </div>
    </div>
    <div id="local-search-result"></div>
</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>


</body>
</html>
